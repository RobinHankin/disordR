[{"path":"https://robinhankin.github.io/disordR/CODE_OF_CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor covenant code of conduct","title":"Contributor covenant code of conduct","text":"members, contributors, leaders wish make participation community pleasant productive experience everyone. try act interact ways contribute open, welcoming, inclusive, healthy community. assume good faith, per WP:AGF. Examples behaviour contributes positive environment community include: Demonstrating empathy kindness toward people Communicating respectfully differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community","code":""},{"path":"https://robinhankin.github.io/disordR/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to disordR","title":"Contributing to disordR","text":"Thank considering contributing disordR! appreciate interest making project better. Please read adhere Code Conduct maintain safe, welcoming, inclusive environment. Various forms contributions welcome: Bug Reports: Feel free report bugs encounter. Documentation: Typos, clarity issues, missing guides: help welcome . Feature Discussions/Requests: Got idea? Open issue discuss potential. Code Contributions: code contributions welcome. Tests checks run CI, however locally one can use: devtools::test(). Ideally change documented. Major changes vignettes.","code":""},{"path":"https://robinhankin.github.io/disordR/articles/disordR.html","id":"abstract","dir":"Articles","previous_headings":"","what":"Abstract","title":"The `disordR` package: design philosophy and a use-case in multivariate polynomials","text":"cite disordR package publications please use Hankin (2022). document motivates concept “disordered vector” using coefficients multivariate polynomials represented associative maps STL map class used mvp package. Values keys map stored implementation-specific way certain extraction replacement operations forbidden. example, consider finite set S real numbers. “first” element S implementation specific (set specify order elements)…maximum value S well-defined value, sum. disordR package makes impossible execute forbidden operations (finding “first” element), allowing transparent R idiom permitted operations finding maximum sum. Note one dispense order entirely, wish consider keys values STL objects separately, need retain ability match individual keys corresponding values. illustrative R session given disordR package used abstractly, without reference particular application, shows disordR package used mvp package. disordR used clifford, freealg, hyper2, mvp, spray, stokes, weyl packages.","code":""},{"path":"https://robinhankin.github.io/disordR/articles/disordR.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The `disordR` package: design philosophy and a use-case in multivariate polynomials","text":"C++ (ISO Central Secretary 1998), STL map class (Josuttis 1999) object associates value set keys. Accessing values keys map object problematic value-key pairs stored well-defined order. situation applicable package uses map objects. Consider, example, mvp package deals multinomials using STL maps. mvp object map terms coefficients, map intrinsic ordering: maps map correspond multinomial (symbolically, x+3y+3xy+4xy3=4xy3+3xy+x+3yx+3y+3xy+4xy^3=4xy^3+3xy+x+3y). Thus coefficients multinomial might c(1,3,3,4) c(4,3,1,3), indeed ordering. Internally, elements stored order order used implementation-specific. Quite often, interested coefficients per se, without consideration meaning context multivariate polynomial. might ask: “many coefficients ?” “largest coefficient?” “coefficients exactly equal one?” “many coefficients greater 2?” reasonable mathematically meaningful questions answer independent order coefficients stored. Compare meaningless question: “second coefficient?”. meaningless order ambiguity discussed : answer best implementation-specific, fundamentally question one allowed ask. deal coefficients isolation R, one might tempted use multiset. However, approach allow one link coefficients terms. Suppose coerce coefficients multiset object (per sets package, example): impossible extract terms coefficient greater 2 (polynomial 3y+3xy+4xy33y+3xy+4xy^3) link coefficients terms included multiset object. Sensible questions involving aspect mvp objects might : Give terms coefficients greater 2 Give terms positive coefficients Give terms integer coefficients questions answered coefficients stored multiset (compare inadmissible questions “give first three terms”). note replacement methods mathematically meaningful, example: Set term negative coefficient zero Add 100 coefficient less 30 operations reasonable precluded multiset formalism (compare inadmissible replacements: “replace first two terms zero”, “double last term” inadmissible). need system forbids stupid questions stupid operations, permitting sensible questions operations disord class disordR package specificially designed situation. class object slot coefficients form numeric R vector, also another slot uses hash codes prevent users misusing ordering numeric vector. example, multinomial x+2y+3z might coefficients c(1,2,3) c(3,1,2). Package idiom extract coefficients multivariate polynomial coeffs(); return standard numeric vector. stored numeric vector, user might ask “first element?” question asked [certainly answered!], elements stored implementation-specific order. disordR package uses disord objects designed return error inadmissible questions asked. disord objects can answer admissible questions perform admissible operations. Suppose two multivariate polynomials, defined =x+2y+3z b=x+3y+4z. Even though sum +b well-defined algebraically, idiom coeffs() + coeffs(b) defined guarantee coefficients two multivariate polynomials stored order. might c(1,2,3)+c(1,3,4)=c(2,5,7) c(1,2,3)+c(1,4,3)=c(2,6,6), neither “correct” . package, ambiguity rendered void: coeffs() + coeffs(b) return error. Note carefully +b—hence coeffs(+b)—perfectly well defined, although result subject ambiguity coeffs(). way, coeffs() + 1:3 defined return error. , idiom coeffs() <- 1:3and coeffs() <- coeffs(b) defined also return error. However, note perfectly well defined, package idiom behaving expected. Idiom disord() <- disord()^2 OK: one need know order coefficients either side, long order sides. idiomatic English equivalent : “coefficient term becomes square”; note operation insensitive order coefficients. whole shebang intended make idiom coeffs() <- coeffs()%%2 possible, can manipulate polynomials finite rings, Z/2ZZ/2Z. replacement methods defined expression like coeffs()[coeffs() < 5] <- 0 works expected; English idiom “replace coefficient less 5 0”. fix ideas, consider fixed small mvp object: Extraction presents issues; consider coeffs()<3. object Boolean elements ordering ambiguity coeffs(). One might expect use extract elements coeffs(): specifically, elements less 5. may use replace methods coefficients makes sense. Idiom algebraically meaningful allowed package. Idiomatically: “Add 4 element less 5”; “coefficients become parallel maximum 3” respectively. note coeffs() <- rev(coeffs()) disallowed (although coeffs() <- rev(rev(coeffs())) meaningful admissible). output coeffs(x) defined unknown rearrangement. considerations apply output vars(), returns list character vectors undefined order, output powers(), returns numeric list whose elements undefined order. However, even though order three objects undefined individually, ordering jointly consistent sense first element coeffs(x) corresponds first element vars(x) first element powers(x). identity element defined—whatever , first element three accessor methods refers . Note also single term (something like 4a3*b*c^6) issue: variables stored well-defined order. matter algebraic value term depend order variables appear term equivalent 4bc^6*^3.","code":"x -> 1, y -> 3, xy -> 3, xy^3 -> 4 xy^3 -> 4, xy -> 3, x -> 1, y -> 3 coeffs(a) + coeffs(a) coeffs(a) + coeffs(a)^2 coeffs(a) <- coeffs(a)^2 coeffs(a) <- coeffs(a)^2 + 7 library(\"mvp\") ## Loading required package: magrittr ## Loading required package: mpoly ##  ## Attaching package: 'mvp' ## The following objects are masked from 'package:mpoly': ##  ##     is.constant, vars ## The following object is masked from 'package:base': ##  ##     trunc a <- as.mvp(\"5 a c^3 + a^2 d^2 f^2 + 4 a^3 b e^3 + 3 b c f + 2 b^2 e^3\") a ## mvp object algebraically equal to ## 5 a c^3 + a^2 d^2 f^2 + 4 a^3 b e^3 + 3 b c f + 2 b^2 e^3 coeffs(a)[coeffs(a)<5] <- 4 + coeffs(a)[coeffs(a)<5] coeffs(a) <- pmax(a,3)"},{"path":"https://robinhankin.github.io/disordR/articles/disordR.html","id":"an-r-session-with-the-disordr-package","dir":"Articles","previous_headings":"","what":"An R session with the disordR package","title":"The `disordR` package: design philosophy and a use-case in multivariate polynomials","text":"use disordR package show idiom works. Object disord object behaves similarly regular numeric vector many ways: , note result hash code . operations make sense max() sort(): , see result standard numeric vector. However, inadmissible operations give error: Standard R semantics generally work expected: , observe objects , x y hash code: “compatible”, disordR idiom. However, try combine object another object different hash, get errors: error given objects b stored implementation-specific order (say b incompatible). package, many extract replace methods implemented whenever admissible: Usual semantics follow, provided one careful maintain hash code: , replacement command works d e e<4 [Boolean disord object] hash code.","code":"library(\"disordR\") ## Loading required package: Matrix set.seed(0) a <- rdis() a ## A disord object with hash df89f9719c6a2e5869972193649230ab78025e43 and elements ## [1] 9 4 7 1 2 7 2 3 1 ## (in some order) a^2 ## A disord object with hash df89f9719c6a2e5869972193649230ab78025e43 and elements ## [1] 81 16 49  1  4 49  4  9  1 ## (in some order) a+1/a ## A disord object with hash df89f9719c6a2e5869972193649230ab78025e43 and elements ## [1] 9.111111 4.250000 7.142857 2.000000 2.500000 7.142857 2.500000 3.333333 ## [9] 2.000000 ## (in some order) max(a) ## [1] 9 sort(a) ## [1] 1 1 2 2 3 4 7 7 9 a[1]  # asking for the first element is inadmissible ## Error in .local(x, i, j = j, ..., drop): if using a regular index to extract, must extract each element once and once only (or none of them) a[1] <- 1000 # also cannot replace the first element ## Error in .local(x, i, j = j, ..., value): if using a regular index to replace, must specify each element once and once only x <- a + 1/a x ## A disord object with hash df89f9719c6a2e5869972193649230ab78025e43 and elements ## [1] 9.111111 4.250000 7.142857 2.000000 2.500000 7.142857 2.500000 3.333333 ## [9] 2.000000 ## (in some order) y <- a*2-9 y ## A disord object with hash df89f9719c6a2e5869972193649230ab78025e43 and elements ## [1]  9 -1  5 -7 -5  5 -5 -3 -7 ## (in some order) x+y ## A disord object with hash df89f9719c6a2e5869972193649230ab78025e43 and elements ## [1] 18.1111111  3.2500000 12.1428571 -5.0000000 -2.5000000 12.1428571 -2.5000000 ## [8]  0.3333333 -5.0000000 ## (in some order) b <- rdis() b ## A disord object with hash 13e1ca01d7ffd8c88d86eddd9719646a6501ec3d and elements ## [1] 5 6 7 9 5 5 9 9 5 ## (in some order) a ## A disord object with hash df89f9719c6a2e5869972193649230ab78025e43 and elements ## [1] 9 4 7 1 2 7 2 3 1 ## (in some order) a+b ##  ## disordR discipline error in: ## a + b ## Error in check_matching_hash(e1, e2, match.call()):  ## hash codes df89f9719c6a2e5869972193649230ab78025e43 and 13e1ca01d7ffd8c88d86eddd9719646a6501ec3d do not match a[a<0.5] <- 0  # round down a ## A disord object with hash df89f9719c6a2e5869972193649230ab78025e43 and elements ## [1] 9 4 7 1 2 7 2 3 1 ## (in some order) b[b>0.6] <- b[b>0.6] + 3  # add 3 to every element greater than 0.6 b ## A disord object with hash 13e1ca01d7ffd8c88d86eddd9719646a6501ec3d and elements ## [1]  8  9 10 12  8  8 12 12  8 ## (in some order) d <- disord(1:10) d ## A disord object with hash 6ff3b61e758e070a5137a5b8777a25533ca70a1c and elements ##  [1]  1  2  3  4  5  6  7  8  9 10 ## (in some order) e <- 10 + 3*d - d^2 e ## A disord object with hash 6ff3b61e758e070a5137a5b8777a25533ca70a1c and elements ##  [1]  12  12  10   6   0  -8 -18 -30 -44 -60 ## (in some order) e<4 ## A disord object with hash 6ff3b61e758e070a5137a5b8777a25533ca70a1c and elements ##  [1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE ## (in some order) d[e<4] <- e[e<4] d ## A disord object with hash 6ff3b61e758e070a5137a5b8777a25533ca70a1c and elements ##  [1]   1   2   3   4   0  -8 -18 -30 -44 -60 ## (in some order)"},{"path":"https://robinhankin.github.io/disordR/articles/disordR.html","id":"an-r-session-with-the-mvp-package","dir":"Articles","previous_headings":"","what":"An R session with the mvp package","title":"The `disordR` package: design philosophy and a use-case in multivariate polynomials","text":"mvp package implements multivariate polynomials using STL map class. Following commands work intended mvp >= 1.0-12. see disordR idiom allows mathematically meaningful operation suppressing inadmissible ones: Observe standard multivariate polynomial algebra works: can extract coefficients polynomials using coeffs() function: observe coefficients returned disord object. may manipulate coefficients polynomial many ways. may following things: However, many operations reasonable idiom fact meaningless implicitly prohibited. example: following produce errors:","code":"library(\"mvp\") set.seed(0) a <- rmvp() b <- rmvp() a ## mvp object algebraically equal to ## 3 a b^9 e^4 f + 7 a^2 b^4 d^6 e f^4 + 4 a^4 b^6 c^5 d^11 f^4 + 6 a^6 b^3 c^14 ## f^2 + 5 a^11 e^6 f^6 + b^8 e^7 f^12 + 2 b^10 d^10 f^4 b ## mvp object algebraically equal to ## 5 a c^2 e^8 f^7 + 4 a^2 b^5 c^6 e^3 + 7 a^2 b^7 c^4 d e^2 + a^4 d^6 e^5 f + 6 ## a^6 d^6 f^6 + 3 b^7 c^7 e^5 + 2 b^10 c^3 f^7 a + 2*b ## mvp object algebraically equal to ## 3 a b^9 e^4 f + 10 a c^2 e^8 f^7 + 7 a^2 b^4 d^6 e f^4 + 8 a^2 b^5 c^6 e^3 + 14 ## a^2 b^7 c^4 d e^2 + 4 a^4 b^6 c^5 d^11 f^4 + 2 a^4 d^6 e^5 f + 6 a^6 b^3 c^14 ## f^2 + 12 a^6 d^6 f^6 + 5 a^11 e^6 f^6 + 6 b^7 c^7 e^5 + b^8 e^7 f^12 + 4 b^10 ## c^3 f^7 + 2 b^10 d^10 f^4 (a+b)*(a-b) == a^2-b^2   # should be TRUE (expression is quite long) ## [1] TRUE coeffs(a) ## A disord object with hash 76b070e3d27bf2e3a548b56a02678d79881de0ce and elements ## [1] 3 7 4 6 5 1 2 ## (in some order) coeffs(b) ## A disord object with hash 40b9beff42bebe889cb596f78d096c90ef279834 and elements ## [1] 5 4 7 1 6 3 2 ## (in some order) coeffs(a)[coeffs(a) < 4] <- 0   # set any coefficient of a that is <4 to zero a ## mvp object algebraically equal to ## 7 a^2 b^4 d^6 e f^4 + 4 a^4 b^6 c^5 d^11 f^4 + 6 a^6 b^3 c^14 f^2 + 5 a^11 e^6 ## f^6 coeffs(b) <- coeffs(b)%%2       # consider coefficients of b modulo 2 b ## mvp object algebraically equal to ## a c^2 e^8 f^7 + a^2 b^7 c^4 d e^2 + a^4 d^6 e^5 f + b^7 c^7 e^5 x <- rmvp()     # set up new mvp objects x and y y <- rmvp() coeffs(x) + coeffs(y)  # order implementation specific ##  ## disordR discipline error in: ## coeffs(x) + coeffs(y) ## Error in check_matching_hash(e1, e2, match.call()):  ## hash codes 70fa3d05d5b2549b4c29d1938fe380f5d49d9844 and 7e74a4c559eedc67cc7ac322e8b61c2e4dbe7e71 do not match coeffs(x) <- coeffs(y) # ditto ## Error in `coeffs<-.mvp`(`*tmp*`, value = new(\"disord\", .Data = c(5, 2, : consistent(vars(x), value) is not TRUE coeffs(x) <- 1:2       # replacement value not length 1 ##  ## disordR discipline error in: ## .local(x = x, i = i, j = j, value = value) ## Error in check_matching_hash(x, value, match.call()):  ## cannot combine disord object with hash code 70fa3d05d5b2549b4c29d1938fe380f5d49d9844 with a vector coeffs(x)[coeffs(x) < 3] <- coeffs(x)[coeffs(y) < 3] ##  ## disordR discipline error in: ## .local(x = x, i = i, j = j, drop = drop) ## Error in check_matching_hash(x, i, match.call()):  ## hash codes 70fa3d05d5b2549b4c29d1938fe380f5d49d9844 and 7e74a4c559eedc67cc7ac322e8b61c2e4dbe7e71 do not match"},{"path":"https://robinhankin.github.io/disordR/articles/disordR.html","id":"vars-and-powers-return-disord-objects","dir":"Articles","previous_headings":"An R session with the mvp package","what":"vars() and powers() return disord objects","title":"The `disordR` package: design philosophy and a use-case in multivariate polynomials","text":"disord() function takes list argument, useful working mvp objects: Note hash three objects identical, generated polynomial (just relevant element three-element list mvp object). allows us rather interesting things: , multivariate polynomial doubled powers variables terms coefficients less 4. even: , took multivariate polynomial replaced variable names every term four variables uppercase equivalents.","code":"(a <- as.mvp(\"x^2 + 4 - 3*x*y*z\")) ## mvp object algebraically equal to ## 4 - 3 x y z + x^2 vars(a) ## A disord object with hash 9395842c6e67dfb0be871e04b3a8964a1c9b9bd5 and elements ## [[1]] ## character(0) ##  ## [[2]] ## [1] \"x\" \"y\" \"z\" ##  ## [[3]] ## [1] \"x\" ##  ## (in some order) powers(a) ## A disord object with hash 9395842c6e67dfb0be871e04b3a8964a1c9b9bd5 and elements ## [[1]] ## integer(0) ##  ## [[2]] ## [1] 1 1 1 ##  ## [[3]] ## [1] 2 ##  ## (in some order) coeffs(a) ## A disord object with hash 9395842c6e67dfb0be871e04b3a8964a1c9b9bd5 and elements ## [1]  4 -3  1 ## (in some order) double <- function(x){2*x} (a <- rmvp()) ## mvp object algebraically equal to ## a^2 c^10 d^2 f^2 + 7 a^3 d^5 e^14 + 6 a^5 c^7 d^4 e^2 + 4 a^8 c d^5 e^6 + 2 b^2 ## c^4 d^10 e^5 f + 5 b^2 c^6 d^2 e^7 f^6 + 3 c^6 d^4 e^2 f^6 pa <- powers(a) va <- vars(a) ca <- coeffs(a) pa[ca<4] <- sapply(pa,double)[ca<4] mvp(va,pa,ca) ## mvp object algebraically equal to ## 7 a^3 d^5 e^14 + a^4 c^20 d^4 f^4 + 6 a^5 c^7 d^4 e^2 + 4 a^8 c d^5 e^6 + 5 b^2 ## c^6 d^2 e^7 f^6 + 2 b^4 c^8 d^20 e^10 f^2 + 3 c^12 d^8 e^4 f^12 a <- as.mvp(\"3 + 5*a*b - 7*a*b*x^2 + 2*a*b^2*c*d*x*y -6*x*y + 8*a*b*c*d*x\") a ## mvp object algebraically equal to ## 3 + 5 a b + 8 a b c d x - 7 a b x^2 + 2 a b^2 c d x y - 6 x y pa <- powers(a) va <- vars(a) ca <- coeffs(a) va[sapply(pa,length) > 4] <- sapply(va,toupper)[sapply(pa,length) > 4] mvp(va,pa,ca) ## mvp object algebraically equal to ## 3 + 8 A B C D X + 2 A B^2 C D X Y + 5 a b - 7 a b x^2 - 6 x y"},{"path":[]},{"path":"https://robinhankin.github.io/disordR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Robin K. S. Hankin. Author, maintainer.","code":""},{"path":"https://robinhankin.github.io/disordR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Robin K. S. Hankin (2022). “Disordered vectors R: introducing disordR package.” doi:10.48550/ARXIV.2210.03856, https://arxiv.org/abs/2210.03856.","code":"@Misc{,   title = {Disordered vectors in R: introducing the disordR package},   author = {{Robin K. S. Hankin}},   year = {2022},   publisher = {arXiv},   doi = {10.48550/ARXIV.2210.03856},   url = {https://arxiv.org/abs/2210.03856}, }"},{"path":[]},{"path":"https://robinhankin.github.io/disordR/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Non-Ordered Vectors","text":"Ordinary R vectors unsuitable working values associative maps elements R vector may accessed reference location vector, associative maps stored arbitrary order. However, associating keys values one needs parts 1-1 correspondence, one dispense order entirely. disordR package includes single S4 class, disord. class allows one perform operations appropriate manipulating values (keys) associative maps. useful heuristic one allowed access modify disord object using python list comprehension. idea prevent “illegal” operations values (keys) associative maps, whose order undefined best implementation-specific, allowing sensible operations.","code":""},{"path":"https://robinhankin.github.io/disordR/index.html","id":"the-disord-package-in-use","dir":"","previous_headings":"","what":"The disord package in use","title":"Non-Ordered Vectors","text":"illustrate package examples legal illegal code. First create simple disord object: may perform various operations object: difficulty. try find elements particular offset offsets, system returns error: elements stored implementation-specific order thing “first” element. may manipulate elements reference values position vector: Replacement methods can access subsets makes sense:","code":"set.seed(0) a <- rdis()    # a random disord object a #> A disord object with hash 5b7279f3c05d00cf1e8f999a755151e0451c56ec and elements #> [1] 9 4 7 1 2 6 3 8 5 #> (in some order) a+4 #> A disord object with hash 5b7279f3c05d00cf1e8f999a755151e0451c56ec and elements #> [1] 13  8 11  5  6 10  7 12  9 #> (in some order) a > 5 #> A disord object with hash 5b7279f3c05d00cf1e8f999a755151e0451c56ec and elements #> [1]  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE #> (in some order) a[a<6] #> A disord object with hash 1cb2c1cb8b5cb3c58e69ffcc5f88340cbdc6abbd and elements #> [1] 4 1 2 3 5 #> (in some order) a[1] #> Error in .local(x, i, j = j, ..., drop): if using a regular index to extract, must extract each element once and once only (or none of them) a[c(2,3)] #> Error in .local(x, i, j = j, ..., drop): if using a regular index to extract, must extract each element once and once only (or none of them) a[a<3] <- 0  # round small elements down a #> A disord object with hash 5b7279f3c05d00cf1e8f999a755151e0451c56ec and elements #> [1] 9 4 7 0 0 6 3 8 5 #> (in some order) x <- disord(1:10) x #> A disord object with hash 65e11d78de79b7f584068ad856749e3748cb837c and elements #>  [1]  1  2  3  4  5  6  7  8  9 10 #> (in some order) x[x<3] <- x[x<3] + 100 x #> A disord object with hash 65e11d78de79b7f584068ad856749e3748cb837c and elements #>  [1] 101 102   3   4   5   6   7   8   9  10 #> (in some order)"},{"path":"https://robinhankin.github.io/disordR/index.html","id":"two-distinct-disord-objects","dir":"","previous_headings":"","what":"Two distinct disord objects","title":"Non-Ordered Vectors","text":"create another disord object, b: b length, adding vectorially forbidden order elements implementation-specific: Also, replacement methods access cross-referenced locations forbidden: (observe carefully [b<14] <- 5 legal). However, sometimes one knows two disord objects ordering (perhaps key, b value, associative array). case one may cross-reference provided hash codes two objects agree: See b hash code. , although elements b stored implementation-specific (thus unknown) order, whatever order objects relatable:","code":"b <- rdis() b #> A disord object with hash 488e1c6f4e2c062379d47b5511730a9785661318 and elements #> [1] 2 3 8 1 5 6 9 7 4 #> (in some order) a+b #> disordR discipline error in: #> a + b #>  #> hash codes 5b7279f3c05d00cf1e8f999a755151e0451c56ec and 488e1c6f4e2c062379d47b5511730a9785661318 do not match #> Error in check_matching_hash(e1, e2, match.call()): stopping a[b < 4] <- 5 #> disordR discipline error in: #> .local(x = x, i = i, j = j, value = value) #>  #> hash codes 5b7279f3c05d00cf1e8f999a755151e0451c56ec and 488e1c6f4e2c062379d47b5511730a9785661318 do not match #> Error in check_matching_hash(x, i, match.call()): stopping a <- rdis() b <- disord(sample(9),hash(a)) a #> A disord object with hash 909ab9cb9afebb8a5109f17b277b37d7e6b1aaa1 and elements #> [1] 7 1 9 5 6 8 4 2 3 #> (in some order) b #> A disord object with hash 909ab9cb9afebb8a5109f17b277b37d7e6b1aaa1 and elements #> [1] 5 2 8 6 1 4 3 9 7 #> (in some order) a+b #> A disord object with hash 909ab9cb9afebb8a5109f17b277b37d7e6b1aaa1 and elements #> [1] 12  3 17 11  7 12  7 11 10 #> (in some order) a[b < 0.5] #> integer(0) a[b < 0.2] <- b[b < 0.2] a #> A disord object with hash 909ab9cb9afebb8a5109f17b277b37d7e6b1aaa1 and elements #> [1] 7 1 9 5 6 8 4 2 3 #> (in some order)"},{"path":"https://robinhankin.github.io/disordR/index.html","id":"comparison-with-python","dir":"","previous_headings":"","what":"Comparison with python","title":"Non-Ordered Vectors","text":"disord object comparable python arrays proviso one allowed access manipulate elements via list comprehensions. See following python session: Note last line zip() used relate b accomplished package explicitly setting hash code.","code":"~ % python3 Python 3.9.5 (default, May  4 2021, 03:33:11)  [Clang 12.0.0 (clang-1200.0.32.29)] on darwin Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> from numpy import * >>> a = random.rand(5) >>> b = random.rand(5) >>> a array([0.13275574, 0.07243463, 0.0543058 , 0.36633955, 0.73795801]) >>> b array([0.14934221, 0.11321413, 0.6135964 , 0.53558058, 0.6396702 ]) >>> [i**2 for i in a] [0.017624086607707354, 0.005246776214236293, 0.002949120389839953, 0.1342046637421116, 0.54458202262916] >>> [i+j for i,j in zip(a,b)] [0.28209795105056, 0.18564876373593042, 0.6679022004516395, 0.901920128499422, 1.377628206483919] >>>"},{"path":"https://robinhankin.github.io/disordR/reference/arith.html","id":null,"dir":"Reference","previous_headings":"","what":"Arithmetic operations — Arith","title":"Arithmetic operations — Arith","text":"Arithmetic operations including low-level helper functions","code":""},{"path":"https://robinhankin.github.io/disordR/reference/arith.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arithmetic operations — Arith","text":"","code":"disord_inverse(a) disord_mod_disord(a,b) disord_mod_numeric(a,b) disord_negative(a) disord_plus_disord(a,b) disord_plus_numeric(a,b) disord_power_disord(a,b) disord_power_numeric(a,b) numeric_power_disord(a,b) disord_prod_disord(a,b) disord_prod_numeric(a,b) disord_arith_unary(e1,e2) disord_arith_disord(e1,e2) disord_arith_numeric(e1,e2) numeric_arith_disord(e1,e2)"},{"path":"https://robinhankin.github.io/disordR/reference/arith.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arithmetic operations — Arith","text":",b least one disord object e1,e2 Formal arguments S4 dispatch","code":""},{"path":"https://robinhankin.github.io/disordR/reference/arith.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Arithmetic operations — Arith","text":"Basic low-level arithmetic operations, intended called S4 dispatch. functions return disord object regular vector appropriate.  Consistency required.  hash set disord object appropriate.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/arith.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Arithmetic operations — Arith","text":"Arith signature(e1=\"disord\", e2=\"disord\"):       Dispatched disord_arith_disord() Arith signature(e1=\"disord\", e2=\"numeric\"):       Dispatched disord_arith_numeric() Arith signature(e1=\"numeric\", e2=\"disord\"):       Dispatched numeric_arith_disord() Arith signature(e1=\"disord\", e2=\"missing\"):       Dispatched disord_arith_unary()","code":""},{"path":"https://robinhankin.github.io/disordR/reference/arith.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arithmetic operations — Arith","text":"Return disord object logical","code":""},{"path":"https://robinhankin.github.io/disordR/reference/arith.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Arithmetic operations — Arith","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/disordR/reference/arith.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arithmetic operations — Arith","text":"","code":"a <- rdis() a #> A disord object with hash 88cd8470b37ad8c0a422741433043268f070e15f and elements #> [1] 7 5 6 4 6 9 5 5 8 #> (in some order) a + 2*a #> A disord object with hash 88cd8470b37ad8c0a422741433043268f070e15f and elements #> [1] 21 15 18 12 18 27 15 15 24 #> (in some order) a > 5 #> A disord object with hash 88cd8470b37ad8c0a422741433043268f070e15f and elements #> [1]  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE #> (in some order) a[a > 5] <- a[a > 5] + 100 a #> A disord object with hash 88cd8470b37ad8c0a422741433043268f070e15f and elements #> [1] 107   5 106   4 106 109   5   5 108 #> (in some order)"},{"path":"https://robinhankin.github.io/disordR/reference/c.html","id":null,"dir":"Reference","previous_headings":"","what":"Concatenation — c","title":"Concatenation — c","text":"Concatenation simply make sense disord objects.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/c.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Concatenation — c","text":"Returns error.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/c.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Concatenation — c","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/disordR/reference/c.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Concatenation — c","text":"figure stop idiom like “c(1,rdis())”   returning result.  Just use , OK?","code":""},{"path":"https://robinhankin.github.io/disordR/reference/compare.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for comparison of disord objects — Compare-methods","title":"Methods for comparison of disord objects — Compare-methods","text":"Arithmetic comparison methods (greater , etc) disord objects.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/compare.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Methods for comparison of disord objects — Compare-methods","text":"Compare signature(e1=\"disord\", e2=\"disord\"):       Dispatched disord_compare_disord() Compare signature(e1=\"disord\", e2=\"\"):       Dispatched disord_compare_any() Compare signature(e1=\"\", e2=\"disord\"):       Dispatched any_compare_disord()","code":""},{"path":"https://robinhankin.github.io/disordR/reference/compare.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Methods for comparison of disord objects — Compare-methods","text":"comparison methods use drop=TRUE avoid inconsistent results values [, TRUE FALSE].  Comparing two disord objects requires hash code agree per disordR discipline.  Comparing disord numeric returns disord object.  case, hash code original object preserved returned value.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/compare.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for comparison of disord objects — Compare-methods","text":"","code":"rdis() > 4 #> A disord object with hash a3aaab0ff8b5fbbe0c3fb5f79387e72a97137c9f and elements #> [1] FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE #> (in some order) rdis() > 1000 #> A disord object with hash 91bfd353776eb2945b43942e92aab1bf36329204 and elements #> [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE #> (in some order)"},{"path":"https://robinhankin.github.io/disordR/reference/consistent.html","id":null,"dir":"Reference","previous_headings":"","what":"Check for consistency — consistent","title":"Check for consistency — consistent","text":"disordR package designed make permitted operations   transparent prevent forbidden operations executed. Function consistent() checks matching hash codes   arguments returns Boolean.  called function   check_matching_hash() either returns TRUE   reports informative error message .","code":""},{"path":"https://robinhankin.github.io/disordR/reference/consistent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check for consistency — consistent","text":"","code":"consistent(x,y) x %~% y check_matching_hash(e1,e2,use=NULL)"},{"path":"https://robinhankin.github.io/disordR/reference/consistent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check for consistency — consistent","text":"x,y,e1,e2 Objects class disord use optional object designed give intelligible error     message; typically match.call()","code":""},{"path":"https://robinhankin.github.io/disordR/reference/consistent.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check for consistency — consistent","text":"Function consistent() checks arguments   hash code, thus elements can paired (e.g. added).   Idiom %~% b equivalent consistent(,b). package generally checks consistency function   check_matching_hash() provides helpful diagnostics   consistent() finds hash mismatch.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/consistent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check for consistency — consistent","text":"Boolean error appropriate","code":""},{"path":"https://robinhankin.github.io/disordR/reference/consistent.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check for consistency — consistent","text":"Robin K. S. Hankin","code":""},{"path":[]},{"path":"https://robinhankin.github.io/disordR/reference/consistent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check for consistency — consistent","text":"","code":"# rdis() + rdis() # this would make check_matching_hash() report an error, if executed"},{"path":"https://robinhankin.github.io/disordR/reference/disindex-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Experimental class ","title":"Experimental class ","text":"Experimental disindex class provides disordR-compliant   method indexing disord objects.  idea   (x), x Boolean class disord,   meaning disordR discipline.  Thus   () gives disindex object.  object can   used index disord objects.  One application   dismat class matrices, currently   development. Function values() coerces argument integer vector.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/disindex-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Experimental class ","text":"Objects can created calls form new(\"disindex\", ...), although () natural.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/disindex-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Experimental class ","text":"value: Numeric vector hash: Object class character       specifies hash code","code":""},{"path":"https://robinhankin.github.io/disordR/reference/disindex-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Experimental class ","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/disordR/reference/disindex-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Experimental class ","text":"","code":"(x <- disord(c(1,2,1,2,2,7))) #> A disord object with hash cdeefb8287cacbeb91786b8e396fadc953ae76ec and elements #> [1] 1 2 1 2 2 7 #> (in some order)  x==2 #> A disord object with hash cdeefb8287cacbeb91786b8e396fadc953ae76ec and elements #> [1] FALSE  TRUE FALSE  TRUE  TRUE FALSE #> (in some order) w <- which(x==2) w #> A disind object with hash cdeefb8287cacbeb91786b8e396fadc953ae76ec and 3 (implementation-specific) elements  x[w] <- 100 x #> A disord object with hash 2e67051b252655628b9f283bbf6bf820e246a46f and elements #> [1]   1 100   1 100 100   7 #> (in some order)"},{"path":"https://robinhankin.github.io/disordR/reference/disord-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class ","title":"Class ","text":"disord class provides basic arithmetic extract/replace   methods disord objects.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/disord-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Class ","text":"Objects can created calls form new(\"disord\", ...), although functions disord() (eventually) .disord() user-friendly.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/disord-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class ","text":".Data: Object class vector specifies       elements hash: Object class character       specifies hash code","code":""},{"path":"https://robinhankin.github.io/disordR/reference/disord-class.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Class ","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/disordR/reference/disord-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class ","text":"","code":"showClass(\"disord\") #> Class \"disord\" [package \"disordR\"] #>  #> Slots: #>                            #> Name:      .Data      hash #> Class:    vector character #>  #> Extends:  #> Class \"vector\", from data part"},{"path":"https://robinhankin.github.io/disordR/reference/disord.html","id":null,"dir":"Reference","previous_headings":"","what":"Functionality for disord objects — disord","title":"Functionality for disord objects — disord","text":"Allows arithmetic operators used disord objects;   canonical application coefficients multivariate polynomials (  mvp package).  issue storage order   disord objects implementation-specific order (whatever   ) must consistent list keys values   associative array.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/disord.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functionality for disord objects — disord","text":"","code":"is.disord(x) hash(x) hashcal(x,ultra_strict=FALSE) disord(v,h,drop=TRUE) elements(x)"},{"path":"https://robinhankin.github.io/disordR/reference/disord.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functionality for disord objects — disord","text":"x Object class disord v Vector coefficients h Hash code drop Boolean, default FALSE meaning return     disord object TRUE meaning call drop()     returning ultra_strict Boolean, default FALSE meaning use     just x generate hash, TRUE meaning use     date random number well [ensures hash     generated ]","code":""},{"path":"https://robinhankin.github.io/disordR/reference/disord.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functionality for disord objects — disord","text":"detailed vignette provided motivates package.    applications mvp clifford packages,   user need even think disordR   package: works background.  purpose package   trap plausible idiom ill-defined (implementation-specific)   return informative error, rather returning possibly   incorrect result. package provides single S4 class, disord,   two slots, .Data hash. Function disord() takes R object vector list   returns disord object, useful context   STL map class. Function hash() returns hash object (compare   hashcal() used actually calculate hash code). package detects acceptable forbidden operations using hash   codes: function consistent() checks arguments   hash code, thus elements can paired   (e.g. added).  Idiomatically, %~% b equivalent   consistent(,b). Function elements() takes disord returns regular   R object, typically vector list.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/disord.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functionality for disord objects — disord","text":"Boolean, hash code, object class disord   appropriate.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/disord.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Functionality for disord objects — disord","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/disordR/reference/disord.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functionality for disord objects — disord","text":"","code":"(a <- rdis()) #> A disord object with hash 562bf29b43ffc08be6e77bf798a9218e959665fa and elements #> [1] 1 6 2 3 1 9 2 5 8 #> (in some order) (b <- rdis()) #> A disord object with hash 6846ea800c0749e0f2b0b75d0c797690ad33502e and elements #> [1] 3 3 2 7 3 6 4 1 7 #> (in some order)  a + 2*a + 2^a  # fine #> A disord object with hash 562bf29b43ffc08be6e77bf798a9218e959665fa and elements #> [1]   5  82  10  17   5 539  10  47 280 #> (in some order) # a + b # this would give an error if executed  a[a<0.5] <- 0       # round down; replacement works as expected  elements(a) #> [1] 1 6 2 3 1 9 2 5 8"},{"path":"https://robinhankin.github.io/disordR/reference/drop.html","id":null,"dir":"Reference","previous_headings":"","what":"Drop redundant information — drop","title":"Drop redundant information — drop","text":"Coerce disord objects vector makes sense","code":""},{"path":"https://robinhankin.github.io/disordR/reference/drop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Drop redundant information — drop","text":"","code":"drop(x) allsame(x)"},{"path":"https://robinhankin.github.io/disordR/reference/drop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Drop redundant information — drop","text":"x disord object","code":""},{"path":"https://robinhankin.github.io/disordR/reference/drop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Drop redundant information — drop","text":"one disord object whose elements identical, one   usually wants drop disord attribute coerce vector.   can done without breaking disordR discipline.  Function   disord() takes drop argument, defaulting   TRUE, drops disord class return value   elements . Similarly, function drop() takes disord object   elements identical returns elements form   vector.  extraction methods take drop argument,   thing TRUE.  useful disord   objects created disord(...,drop=FALSE) drop functionality conceptually similar   drop argument base R's array extraction,  Function allsame() takes vector returns TRUE   elements identical.","code":"a <- matrix(1:30,5,6)      a[1,,drop=TRUE]      a[1,,drop=FALSE]"},{"path":"https://robinhankin.github.io/disordR/reference/drop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Drop redundant information — drop","text":"Function drop() returns either vector object class   disord appropriate; allsame() returns Boolean.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/drop.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Drop redundant information — drop","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/disordR/reference/drop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Drop redundant information — drop","text":"","code":"disord(c(3,3,3,3,3))             # default is drop=TRUE #> [1] 3 3 3 3 3 disord(c(3,3,3,3,3),drop=FALSE)  # retains disord class #> A disord object with hash e81796e3a93fcec2f29b56dd3fe9dfdc43535326 and elements #> [1] 3 3 3 3 3 #> (in some order)  drop(disord(c(3,3,3,3),drop=FALSE))  #> [1] 3 3 3 3  ## In extraction, argument drop discards disorderliness when possible: a <- rdis() a #> A disord object with hash 50f908fd5b0bbb8ab03f9aec07c881282b83fa4d and elements #> [1] 2 8 1 1 7 6 9 2 6 #> (in some order) a[] <- 6 # a becomes a vector a #> [1] 6 6 6 6 6 6 6 6 6"},{"path":"https://robinhankin.github.io/disordR/reference/extract.html","id":null,"dir":"Reference","previous_headings":"","what":"Extraction and replacement methods for class ","title":"Extraction and replacement methods for class ","text":"disord class provides basic arithmetic extract/replace   methods disord objects. Class index taken excellent Matrix package setClassUnion() classes numeric, logical, character.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/extract.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Extraction and replacement methods for class ","text":"[ signature(x = \"disord\", = \"\", j = \"\"): ... [ signature(x = \"disord\", = \"index\", j = \"index\"): ... [ signature(x = \"disord\", = \"index\", j = \"missing\"): ... [ signature(x = \"disord\", = \"missing\", j = \"index\"): ... [ signature(x = \"disord\", = \"missing\", j = \"missing\"): ... [ signature(x = \"disord\", = \"matrix\", j = \"missing\"): ... [<- signature(x = \"disord\", = \"index\", j = \"index\"): ... [<- signature(x = \"disord\", = \"index\", j = \"missing\"): ... [<- signature(x = \"disord\", = \"missing\", j = \"index\"): ... [<- signature(x = \"disord\", = \"matrix\", j = \"missing\"): ... [<- signature(x = \"disord\", = \"missing\", j = \"missing\"): ... [[ signature(x = \"disord\", = \"index\"): ... [[<- signature(x = \"disord\", = \"index\",value=\"\"): ... [ signature(x=\"disord\",=\"disindex\",j=\"missing\",drop=\"\"): ... [ signature(x=\"disord\",=\"disindex\",j=\"\",drop=\"\"): ... [ signature(x=\"\",=\"disindex\",j=\"\",drop=\"\"): ... [ signature(x=\"disord\",=\"disindex\",j=\"missing\",value=\"\"): ... [ signature(x=\"disord\",=\"disindex\",j=\"\",value=\"\"): ... [<- signature(x=\"disord\",=\"disindex\",j=\"missing\",drop=\"\"): ... [[ signature(\"disord\",=\"disindex\"): ... [[ signature(\"\",=\"disindex\"): ... [[<- signature(x=\"disord\",=\"disindex\",j=\"missing\",value=\"\") ... [[<- signature(x=\"\",=\"disindex\",j=\"\",value=\"\") ... extraction method takes drop argument   TRUE, returns drop() value.  Extraction,   x[], rarely useful.  defined one extracts   either , none, elements: anything else undefined.   Note hash code unchanged elements extracted   (order might changed) unchanged none   (one way extract elements). Missing arguments extraction replacement slightly   idiosyncratic.  Extraction idiom x[] returns object   identical x except hash code, changed.    quite see sensible use-case , method allows   one define object y <- x[] x   y incompatible.  Replacement idiom x[] <- v always   coerces vector. Double square extraction, x[[]] x[[]] <-   value, via (experimental) disindex functionality.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/extract.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extraction and replacement methods for class ","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/disordR/reference/extract.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extraction and replacement methods for class ","text":"Package versions prior disordR_0.0-9-6 allowed idiom  now disallowed.  issue discussed   inst/note_on_extraction.Rmd.","code":"a <- disord(1:9)     a[a<3] + a[a>7]"},{"path":[]},{"path":"https://robinhankin.github.io/disordR/reference/extract.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extraction and replacement methods for class ","text":"","code":"a <- disord(sample(9)) a #> A disord object with hash 29bd508dff86896f87b3e2460c72dd285b3640b3 and elements #> [1] 6 9 5 3 4 1 7 8 2 #> (in some order) a + 6*a^2 #> A disord object with hash 29bd508dff86896f87b3e2460c72dd285b3640b3 and elements #> [1] 222 495 155  57 100   7 301 392  26 #> (in some order) a[a>5]  # \"give me all elements of a that exceed 5\" #> A disord object with hash 2240eae098908462ffa368340f2eb57cc80a1f1e and elements #> [1] 6 9 7 8 #> (in some order)  a[] # a disord object, same elements as 'a', but with a different hash #> A disord object with hash c0c06996b929b51603f065cca3af80cf5d8fc8fa and elements #> [1] 6 9 5 3 4 1 7 8 2 #> (in some order)  a[a<5] <- a[a<5] + 100  # \"replace all elements of 'a' less than 5 with their value plus 100\" a #> A disord object with hash 29bd508dff86896f87b3e2460c72dd285b3640b3 and elements #> [1]   6   9   5 103 104 101   7   8 102 #> (in some order)  ## Following expressions would return an error if executed: if(FALSE){   a[1]   a[1] <- 44   a[1:2] <- a[3:4] }  b <- disord(sample(9)) ## Following expressions would also return an error if executed: if(FALSE){   a+b  # (not really an example of extraction)   a[b>5]   a[b>5] <- 100   a[b>5] <- a[b>5] + 44 }"},{"path":"https://robinhankin.github.io/disordR/reference/logic.html","id":null,"dir":"Reference","previous_headings":"","what":"Logical operations — Logic","title":"Logical operations — Logic","text":"Logical operations including low-level helper functions","code":""},{"path":"https://robinhankin.github.io/disordR/reference/logic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logical operations — Logic","text":"","code":"disord_logical_negate(x) disord_logic_disord(e1,e2) disord_logic_any(e1,e2) any_logic_disord(e1,e2)"},{"path":"https://robinhankin.github.io/disordR/reference/logic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logical operations — Logic","text":"e1,e2,x Formal arguments S4 dispatch: logical     disord object","code":""},{"path":"https://robinhankin.github.io/disordR/reference/logic.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Logical operations — Logic","text":"Logic signature(e1=\"disord\", e2=\"disord\"):       Dispatched disord_logic_disord() Logic signature(e1=\"disord\", e2=\"\"):       Dispatched disord_logic_any() Logic signature(e1=\"\", e2=\"disord\"):       Dispatched any_logic_disord()","code":""},{"path":"https://robinhankin.github.io/disordR/reference/logic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Logical operations — Logic","text":"Basic low-level logical operations, intended called S4 dispatch. functions return logical disord object.  appropriate. Consistency required.  hash set disord object appropriate.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/logic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logical operations — Logic","text":"Return disord object logical","code":""},{"path":"https://robinhankin.github.io/disordR/reference/logic.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Logical operations — Logic","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/disordR/reference/logic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Logical operations — Logic","text":"","code":"a <- disord(1:7) l <- a>3 sum(l) #> [1] 4 any(l) #> [1] TRUE all(l | !l) #> [1] TRUE"},{"path":"https://robinhankin.github.io/disordR/reference/misc.html","id":null,"dir":"Reference","previous_headings":"","what":"Miscellaneous functions — misc","title":"Miscellaneous functions — misc","text":"page documents various functions work disords, add time time add new functions make sense disord objects (identify functions break disord discipline). Functions like sin() abs() work expected: take return disord objects hash x (means idiom like x + sin(x) accepted).  However, functions little involved: rev() reverses argument returns disord   object reversed hash, ensures rev(rev(x))==x   (two consistent). sort() returns vector sorted elements (  disord) length() returns length data component   object sapply(X,f) returns disord object result   applying f() element X. match(x,table) behave expected note   table disord, result defined (  known elements x occur table).   Nevertheless x %% table defined returns   disord object. lapply(x,f) returns   disord(lapply(elements(x),f,...),h=hash(x)).  Note double   square bracket extraction, x[[]], disallowed (see   extract.Rd). () returns disind object given   Boolean  disord unlist() takes disord list, flattens   returns disord vector.  requires recursive flag   base::unlist() TRUE, default,   interpreting mean “kill structure   sublists”.  list comprises length-one vectors,   returned value retains hash argument; , new   hash generated. diff() undefined disord objects. rbind() cbind() undefined disord   objects break disord discipline.  Function binder()   returns generic, hopefully informative, error message [  package defines methods rbind2() cbind2()] jitter() takes disord object, jitters   elements, returns disord object correct hash   code.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/misc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Miscellaneous functions — misc","text":"x Object class disord","code":""},{"path":"https://robinhankin.github.io/disordR/reference/misc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Miscellaneous functions — misc","text":"Returns disord","code":""},{"path":"https://robinhankin.github.io/disordR/reference/misc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Miscellaneous functions — misc","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/disordR/reference/misc.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Miscellaneous functions — misc","text":"functionality yet implemented.  Factors, lists, named vectors behave entirely consistently package; paste() gives inconsistent results called disords. Also, () loops incompatible disord discipline, impose ordering (() accesses .Data slot argument, regular R vector).  Thus: , see () uses ordering .Data slot S4 object , even though elements() explicitly called.","code":"> (a <- disord(1:3)) A disord object with hash 555f6bea49e58a2c2541060a21c2d4f9078c3086 and elements [1] 1 2 3 (in some order) > for(i in a){print(i)} [1] 1 [1] 2 [1] 3 >"},{"path":[]},{"path":"https://robinhankin.github.io/disordR/reference/misc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Miscellaneous functions — misc","text":"","code":"a <- disord(c(a=1,b=2,c=7)) a #> A disord object with hash 2ae7dd8fac2a0e3b0bb8fea320a65a6a75b18509 and elements #> [1] 1 2 7 #> (in some order) names(a) #> [1] \"a\" \"b\" \"c\" length(a) #> [1] 3 sqrt(a) #> A disord object with hash 2ae7dd8fac2a0e3b0bb8fea320a65a6a75b18509 and elements #> [1] 1.000000 1.414214 2.645751 #> (in some order)   # powers() and vars() in the mvp package return lists; see the vignette # for more discussion.  l <- disord(list(3,6:9,1:10))   sapply(l,length) #> A disord object with hash a5f0d6ad31332d6e23a554db84a8dfbd83d29649 and elements #> [1]  1  4 10 #> (in some order)  unlist(l) #> A disord object with hash 45570f934ec7f1d23bf8fd1a0f0d1475535bc55f and elements #>  [1]  3  6  7  8  9  1  2  3  4  5  6  7  8  9 10 #> (in some order)  ## Quick illustration of rev():  revstring <- function(s){paste(rev(unlist(strsplit(s, NULL))),collapse=\"\")} x <- rdis() revstring(hash(x)) == hash(rev(x)) #> [1] TRUE"},{"path":"https://robinhankin.github.io/disordR/reference/rdis.html","id":null,"dir":"Reference","previous_headings":"","what":"Random disord objects — rdis","title":"Random disord objects — rdis","text":"Returns random disord object","code":""},{"path":"https://robinhankin.github.io/disordR/reference/rdis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random disord objects — rdis","text":"","code":"rdis(n=9)"},{"path":"https://robinhankin.github.io/disordR/reference/rdis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random disord objects — rdis","text":"n Set sample , interpreted sample()","code":""},{"path":"https://robinhankin.github.io/disordR/reference/rdis.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Random disord objects — rdis","text":"simple disord object,  intended quick   “get going” example","code":""},{"path":"https://robinhankin.github.io/disordR/reference/rdis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random disord objects — rdis","text":"disord object.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/rdis.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Random disord objects — rdis","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/disordR/reference/rdis.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Random disord objects — rdis","text":"","code":"rdis() #> A disord object with hash 0499615eafff46851d736ed34623c229a08bc824 and elements #> [1] 4 2 9 2 3 3 1 7 5 #> (in some order) rdis(99) #> A disord object with hash 92227e0cf4c43dbfe3fc9fc26dab13ac0fecc472 and elements #>  [1] 65  3  7 49 70 91 12 39 11 42 40 15 82 44 54 85 58 29 74 67 14 66 69 82 37 #> [26]  4 83 56 52 57 17 87 31 93 52 74 24 55 73 89 10 73 83 89 51 29 49 79 63 23 #> [51] 57 31 59 75 54 40 60  7 51 92 12  3 16 72 12 66 71 82 26 64 33 90  2 73 57 #> [76] 43 33 16 87 15 32 84 91 65 60 25 10 43 95 60 63 58 63 62 34 42 50 37 19 #> (in some order) rdis(letters) #> A disord object with hash a6430e333ceee13aae0aac6ffcb0c9578bff0a0e and elements #>  [1] \"n\" \"b\" \"u\" \"e\" \"f\" \"s\" \"q\" \"x\" \"h\" \"v\" \"h\" \"n\" \"c\" \"r\" \"o\" \"o\" \"k\" \"x\" \"g\" #> [20] \"z\" \"u\" \"h\" \"z\" \"o\" \"e\" \"p\" #> (in some order)"},{"path":"https://robinhankin.github.io/disordR/reference/show.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for disord objects — show","title":"Print method for disord objects — show","text":"Show methods disords","code":""},{"path":"https://robinhankin.github.io/disordR/reference/show.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for disord objects — show","text":"","code":"# S4 method for class 'disord' show(x) disord_show(x)"},{"path":"https://robinhankin.github.io/disordR/reference/show.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for disord objects — show","text":"x Object class disord","code":""},{"path":"https://robinhankin.github.io/disordR/reference/show.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Print method for disord objects — show","text":"print method simply prints object's hash elements,   together reminder elements listed   implementation-specific order.  Function disord_show()   helper function, really intended end-user.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/show.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print method for disord objects — show","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/disordR/reference/show.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print method for disord objects — show","text":"","code":"print(rdis()) #> A disord object with hash 8fb470bc8b093fbe6836dd35b34f6f97dab3c56e and elements #> [1] 4 1 9 2 7 3 8 3 1 #> (in some order)"},{"path":"https://robinhankin.github.io/disordR/reference/summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Summaries of disord objects — summary.disordR","title":"Summaries of disord objects — summary.disordR","text":"summary method disord objects, print method summaries.","code":""},{"path":"https://robinhankin.github.io/disordR/reference/summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summaries of disord objects — summary.disordR","text":"","code":"# S4 method for class 'disord' summary(object, ...) # S4 method for class 'disindex' summary(object, ...) # S3 method for class 'summary.disord' print(x, ...)"},{"path":"https://robinhankin.github.io/disordR/reference/summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summaries of disord objects — summary.disordR","text":"object,x Object class disord ... arguments, currently ignored","code":""},{"path":"https://robinhankin.github.io/disordR/reference/summary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summaries of disord objects — summary.disordR","text":"summary.disord object summary disord object   x: list first element hash(x)   second summary(elements(x)).  print method just   wrapper .","code":""},{"path":"https://robinhankin.github.io/disordR/reference/summary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summaries of disord objects — summary.disordR","text":"Robin K. S. Hankin","code":""},{"path":"https://robinhankin.github.io/disordR/reference/summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summaries of disord objects — summary.disordR","text":"","code":"summary(rdis(1000)) #> a disord object with hash 73d25c9b054cf1cbf6e377baa0325429ac67b276  #>  #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>     4.0   234.0   486.0   489.5   744.2   998.0"},{"path":"https://robinhankin.github.io/disordR/news/index.html","id":"disordr-09-8-4","dir":"Changelog","previous_headings":"","what":"disordR 0.9-8-4","title":"disordR 0.9-8-4","text":"code conduct contributors’ guide pkgdown jitter()","code":""},{"path":"https://robinhankin.github.io/disordR/news/index.html","id":"disordr-00-9-3","dir":"Changelog","previous_headings":"","what":"disordR 0.0-9-3","title":"disordR 0.0-9-3","text":"bugfix drop=FALSE works disord extraction","code":""},{"path":"https://robinhankin.github.io/disordR/news/index.html","id":"disordr-00-9-2","dir":"Changelog","previous_headings":"","what":"disordR 0.0-9-2","title":"disordR 0.0-9-2","text":"CRAN release: 2022-09-21 Tidy error messages per Writing R extensions, section 1.7 resolves Matrix dependency issue balance, sufficiently stable merit version 1 stop rbind() cbind() breaking disordR discipline","code":""},{"path":"https://robinhankin.github.io/disordR/news/index.html","id":"disordr-00-9","dir":"Changelog","previous_headings":"","what":"disordR 0.0-9","title":"disordR 0.0-9","text":"CRAN release: 2021-12-09 summary method","code":""}]
