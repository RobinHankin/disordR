---
title: "Disordered *matrices* with the `disordR` package: an introduction to class `dismat`"
author: "Robin Hankin"
output: html_document
---

<p style="text-align: right;">
![](`r system.file("help/figures/disordR.png", package = "disordR")`){width=10%}
</p>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In this short experimental discussion I set out the `dismat` virtual
`S4` class.

```{r label=definedismat}
library("disordR")
setClass("dismat",contains = "VIRTUAL", slots = c(x="matrix",hash="character"))
setMethod("elements","dismat",function(x){x@x})  # no occurences of "@" below this line
setMethod("dim","dismat",function(x){dim(elements(x))})
```

OK so now we have a virtual class, and we can access its data using
`disordR::elements()`.  The next step is to create some non-virtual
classes containing `dismat`:

```{r definenonvirtualclasses}

`.value` <- function(x){x@value}  # not exported from package, reproduced here for debugging purposes
setClass("dismat_rd_ci",
         slots    = c(x="matrix",hash="character"),
         contains = "dismat"
         )

setClass("dismat_ri_cd",
         slots    = c(x="matrix",hash="character"),
         contains = "dismat"
         )

setClass("dismat_rd_cd",
         slots    = c(x="matrix",hash="character"),
         contains = "dismat"
         )

`dismat_rd_ci` <- function(M){new("dismat_rd_ci",x=M,hash=hashcal(M))}
`dismat_ri_cd` <- function(M){new("dismat_ri_cd",x=M,hash=hashcal(M))}


setMethod("show", "dismat_rd_ci", function(object){disord_rd_ci_show(object)})

`disord_rd_ci_show` <- function(x){
    cat("A dismat_rd_ci object with hash",hash(x), "and elements\n")
    jj <- x@x
    rownames(jj) <- rep("-",nrow(jj))
    print(jj)
    cat("\n(the rows are in some implementation-specific order)\n")
    return(invisible(x))
}



```

The idea is that we can have a matrix-like object with row or column
indexing via `disindex` objects.  Thus class `dismat_rd_ci` has row
indexing via `dismat` objectss and column indexing via (regular) index
objects, class` dismat_ri_cd` has row indexing via index objects and
column indexing via `disindex` objects, and class `dismat_rd_cd` has
both row and column indexing via `dismat` objects.  First I will
define some extraction methods for `dismat_rd_ci` objects:

```{r label=extractmethodsfordismat_rd_ci}
setMethod("[", signature(x="dismat_rd_ci",i="disindex",j="ANY",drop="ANY"),
          function(x,i,j,drop=TRUE){
	      stopifnot(identical(hash(x),hash(i)))
              if(missing(j)){
                  out <- elements(x)[.value(i),,drop=drop]
              } else {
                  out <- elements(x)[.value(i), j, drop=drop]
              }
              out <- dismat_rd_ci(out)
              if(drop){
                  return(drop(out))
              } else {
                  return(out)
              }
          } )


setMethod("[", signature(x="dismat_rd_ci",i="disord",j="ANY",drop="ANY"),
          function(x,i,j,drop=TRUE){
	  stopifnot(is.logical(i)) # NB:  m <- matrix(1:35,5,7); compare m[c(1,0,0,1,0),] with m[c(T,F,F,T,F),]
	  if(missing(j)){
	    out <- x[which(i), ,drop=drop]  # which(i) is a disindex object
	  } else {
  	    out <- x[which(i),j,drop=drop]
	  }
	  return(out)
	  } )


setMethod("[", signature(x="dismat_rd_ci",i="ANY",j="ANY",drop="ANY"),
          function(x,i,j,drop=TRUE){
              stop("for objects of class 'dismat_rd_ci', the [non-missing, non-empty] row accessor must be of either class 'disindex' or Boolean of class 'disord'; and column accessor must be of class index")
          } )
```

OK Now I will define an object of class `dismat_rd_ci`:

```{r defina}
M <- matrix(1:35,5,7)
a <- dismat_rd_ci(M)
a
rowSums(M) # This is INCORRECT! rowSums() should return a disord object!
colSums(M)
```

Object `a` has rows indexed by `disindex` objects and columns by
regular index objects.  Thus attempting to access rows with a regular
index object should return an error:

```{r showerror,error=TRUE}
a[1,]
```

I am not sure how this will pan out, but the only way to access rows
is to use `apply()`, for which we will need a new method"

```{r defineapplyrdci}
setMethod("apply",signature(X="dismat_rd_ci"),
          function (X, MARGIN, FUN, i_am_sure=FALSE, ..., simplify = TRUE){
              out <- apply(elements(X),MARGIN,FUN,...,simplify=simplify)
              if(MARGIN == 1){
                  return(disord(out,h=hash(X)))
                  } else {
                      if(!i_am_sure){
                          stop("argument 'i_am_sure' is FALSE by default.  If you are _sure_ that FUN is disord-invariant, call apply() with argument i_am_sure=TRUE")
                          } else {
                              return(out)
                          }
                  }
          } )
```

As an example, we will extract just the rows of `a` that are even:

```{r applyapply}
(a_rowsums <- apply(a,1,sum))
(wanted <- a_rowsums%%2==0)
(e <- which(wanted))
```

So `wanted` is a boolean `disord` vector that can be used to extract
rows of `a`:

```{r wantedrowsofa}
a[wanted,]
```

But we can also extract using `e`:

```{r wantedrowsofausinge,error=TRUE}
a[e,]
```





```{r}
setClass("dismat_symm",
         slots    = c(x="matrix",hash="character"),
         contains = "dismat"
         )


```