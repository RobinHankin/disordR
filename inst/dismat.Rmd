---
title: "Disordered *matrices* with the `disordR` package: an introduction to class `dismat`"
author: "Robin Hankin"
output: html_document
---

<p style="text-align: right;">
![](`r system.file("help/figures/disordR.png", package = "disordR")`){width=10%}
</p>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In this short experimental discussion I set out the `dismat` virtual
`S4` class.

```{r label=definedismat}
library("disordR")
setClass("dismat",contains = "VIRTUAL", slots = c(x="matrix",hash="character"))
setMethod("elements","dismat",function(x){x@x})  # no occurences of "@" below this line
setMethod("dim","dismat",function(x){dim(elements(x))})
```

OK so now we have a virtual class, and we can access its data using
`disordR::elements()`.  The next step is to create some non-virtual
classes containing `dismat`:

```{r definenonvirtualclasses}

setClass("dismat_rd_ci",
         slots    = c(x="matrix",hash="character"),
         contains = "dismat"
         )

setClass("dismat_ri_cd",
         slots    = c(x="matrix",hash="character"),
         contains = "dismat"
         )

setClass("dismat_rd_cd",
         slots    = c(x="matrix",hash="character"),
         contains = "dismat"
         )

`dismat_rd_ci` <- function(M){new("dismat_rd_ci",x=M,hash=hashcal(M))}
`dismat_ri_cd` <- function(M){new("dismat_ri_cd",x=M,hash=hashcal(M))}
```

The idea is that we can have a matrix-like object with row or column
indexing via `disindex` objects.  Thus class `dismat_rd_ci` has row
indexing via `dismat` objectss and column indexing via (regular) index
objects, class` dismat_ri_cd` has row indexing via index objects and
column indexing via `disindex` objects, and class `dismat_rd_cd` has
both row and column indexing via `dismat` objects.  First I will
define some extraction methods for `dismat_rd_ci` objects:

```{r label=extractmethodsfordismat_rd_ci}
setMethod("[", signature(x="dismat_rd_ci",i="disindex",j="ANY",drop="ANY"),
          function(x,i,j,drop=TRUE){
	      print("here at setmethod")
	      stopifnot(identical(hash(x),hash(i)))
              if(missing(j)){
	      print("SDfafs")
                  out <- elements(x)[.value(i),,drop=drop]
		  print("jj")
              } else {
                  out <- elements(x)[.value(i), j, drop=drop]
              }
              out <- dismat_ri_cd(out, hash(c(x,i)),drop=FALSE)
              if(drop){
                  return(drop(out))
              } else {
                  return(out)
              }
          } )

setMethod("[", signature(x="dismat_rd_ci",i="ANY",j="ANY",drop="ANY"),
          function(x,i,j,drop=TRUE){
              stop("for objects of class dismat_rd_ci, row accessor must be of class disindex and column accessor must be of class index")
          } )
```

OK Now I will define an object of class `dismat_rd_ci`:

```{r defina}
M <- matrix(1:35,5,7)
a <- dismat_rd_ci(M)
a
rowSums(M)
colSums(M)
```

Object `a` has rows indexed by `disindex` objects and columns by
regular index objects.  Thus attempting to access rows with a regular
index object should return an error:

```{r showerror,error=TRUE}
a[1,]
```

I am not sure how this will pan out, but the only way to access rows
is to use `apply()`, for which we will need a new method"

```{r defineapplyrdci}
setMethod("apply",signature(X="dismat_rd_ci"),
          function (X, MARGIN, FUN, i_am_sure=FALSE, ..., simplify = TRUE){
              out <- apply(elements(X),MARGIN,FUN,...,simplify=simplify)
              if(MARGIN == 1){
                  return(disord(out,h=hash(X)))
                  } else {
                      if(!i_am_sure){
                          stop("argument 'i_am_sure' is FALSE by default.  If you are _sure_ that FUN is disord-invariant, call apply() with argument i_am_sure=TRUE")
                          } else {
                              return(out)
                          }
                  }
          } )

```

As an example, we will extract just the rows of `a` that are even:

```{r applyapply}
(a_rowsums <- apply(a,1,sum))
(wanted <- a_rowsums%%2==0)
(e <- which(wanted))
```

So `wanted` is a boolean that can  be used to extract rows of `a`:

```{r wantedrowsofa,error=TRUE}
a[e,]
traceback()
```



```{r}
setClass("dismat_symm",
         slots    = c(x="matrix",hash="character"),
         contains = "dismat"
         )


```